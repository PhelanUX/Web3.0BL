import React, { useEffect, useState } from "react";
import { ethers } from 'ethers';

import { contractABI, contractAddress } from '../utils/constants';

export const TransactionContext = React.createContext();

const { ethereum } = window;

// Táº O HÃ€M Káº¾T Ná»I Vá»šI CONTRACT
const getEthereumContract = () => {
    const provider = new ethers.providers.Web3Provider(ethereum);
    const signer = provider.getSigner();
    return new ethers.Contract(contractAddress, contractABI, signer);
};
// Táº O PROVIDER
export const TransactionProvider = ({ children }) => {
    const [formData, setFormData] = useState({ addressTo: "", amount: "", keyword: "", message: "" });
    const [currentAccount, setCurrentAccount] = useState("");
    const [isLoading, setIsLoading] = useState(false);
    const [transactionCount, setTransactionCount] = useState(0);
    const [transactions, setTransactions] = useState([]);
    const [lastTxHash, setLastTxHash] = useState("");

    const handleChange = (e, name) => {
        setFormData(prev => ({ ...prev, [name]: e.target.value }));
    };

    // Láº¤Y TXHASH Tá»ª LOCALSTORAGE
    const getStoredTxHash = (index) => {
        return localStorage.getItem(`txHash_${index + 1}`) || null;
    };

    // Láº¤Y Táº¤T Cáº¢ GIAO Dá»ŠCH
    const getAllTransactions = async () => {
        try {
            if (!ethereum) return;

            const contract = getEthereumContract();
            const rawTxs = await contract.getAllTransactions();

            const structured = rawTxs.map((tx, idx) => {
                const storedHash = getStoredTxHash(idx);
                const isLatest = idx === rawTxs.length - 1;
                const hash = storedHash || (isLatest && lastTxHash) || 'Pending...';

                return {
                    addressTo: tx.receiver,
                    addressFrom: tx.sender,
                    timestamp: new Date(tx.timestamp.toNumber() * 1000).toLocaleString(),
                    message: tx.message,
                    keyword: tx.keyword,
                    amount: parseInt(tx.amount._hex) / 1e18,
                    transactionHash: hash,
                };
            });

            setTransactions(structured);
        } catch (error) {
            console.error("getAllTransactions error:", error);
        }
    };

    // KIá»‚M TRA VÃ ÄÃƒ Káº¾T Ná»I
    const checkIfWalletIsConnected = async () => {
        try {
            if (!ethereum) return;

            const accounts = await ethereum.request({ method: 'eth_accounts' });
            if (accounts.length) {
                setCurrentAccount(accounts[0]);
                await getAllTransactions();
            }
        } catch (error) {
            console.error(error);
        }
    };

    // KIá»‚M TRA Sá» LÆ¯á»¢NG GIAO Dá»ŠCH
    const checkIfTransactionsExist = async () => {
        try {
            if (!ethereum) return;

            const contract = getEthereumContract();
            const count = await contract.getTransactionCount();
            const countNum = count.toNumber();

            setTransactionCount(countNum);
            localStorage.setItem("transactionCount", countNum.toString());
        } catch (error) {
            console.error(error);
        }
    };

    // Káº¾T Ná»I VÃ
    const connectWallet = async () => {
        try {
            if (!ethereum) return alert("Please install MetaMask");

            const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
            setCurrentAccount(accounts[0]);
            await getAllTransactions();
        } catch (error) {
            console.error(error);
            throw new Error("No ethereum object");
        }
    };

    // Gá»¬I GIAO Dá»ŠCH
    const sendTransaction = async () => {
        try {
            if (!ethereum) return alert("Please install MetaMask");

            const { addressTo, amount, keyword, message } = formData;
            if (!addressTo || !amount || !keyword || !message) {
                alert("Please fill all fields");
                return;
            }

            const contract = getEthereumContract();
            const parsedAmount = ethers.utils.parseEther(amount);

            // Gá»¬I ETH
            await ethereum.request({
                method: 'eth_sendTransaction',
                params: [{
                    from: currentAccount,
                    to: addressTo,
                    gas: "0x5208",
                    value: parsedAmount._hex,
                }],
            });

            setIsLoading(true);
            console.log("Submitting to blockchain...");

            // Gá»ŒI CONTRACT
            const tx = await contract.addToBlockchain(addressTo, parsedAmount, message, keyword);
            setLastTxHash(tx.hash);

            console.log(`Submitted: ${tx.hash}`);
            await tx.wait();
            console.log(`Confirmed: ${tx.hash}`);

            // Láº¤Y INDEX Má»šI NHáº¤T
            const count = await contract.getTransactionCount();
            const countNum = count.toNumber();

            // LÆ¯U HASH VÄ¨NH VIá»„N
            localStorage.setItem(`txHash_${countNum}`, tx.hash);

            // Cáº¬P NHáº¬T STATE
            setTransactionCount(countNum);
            localStorage.setItem("transactionCount", countNum.toString());

            // Táº¢I Láº I GIAO Dá»ŠCH
            await getAllTransactions();

            setIsLoading(false);

        } catch (error) {
            setIsLoading(false);
            console.error("sendTransaction error:", error);
            alert("Transaction failed");
        }
    };
// KIá»‚M TRA KHI COMPONENT ÄÆ¯á»¢C MOUNT
    useEffect(() => {
        checkIfWalletIsConnected();
        checkIfTransactionsExist();
    }, []);

    return (
        <TransactionContext.Provider value={{
            connectWallet,
            currentAccount,
            formData,
            setFormData,
            handleChange,
            sendTransaction,
            transactions,
            isLoading,
            transactionCount
        }}>
            {children}
        </TransactionContext.Provider>
    );
};


// import React, { useEffect, useState } from "react";
// import { ethers } from 'ethers';

// import { contractABI, contractAddress } from '../utils/constants';

// export const TransactionContext = React.createContext();

// const { ethereum } = window;

// // Táº O HÃ€M Káº¾T Ná»I Vá»šI CONTRACT
// const getEthereumContract = () => {
//     const provider = new ethers.providers.Web3Provider(ethereum);
//     const signer = provider.getSigner();
//     return new ethers.Contract(contractAddress, contractABI, signer);
// };
// // Táº O PROVIDER
// export const TransactionProvider = ({ children }) => {
//     const [formData, setFormData] = useState({ addressTo: "", amount: "", keyword: "", message: "" });
//     const [currentAccount, setCurrentAccount] = useState("");
//     const [isLoading, setIsLoading] = useState(false);
//     const [transactionCount, setTransactionCount] = useState(0);
//     const [transactions, setTransactions] = useState([]);
//     const [lastTxHash, setLastTxHash] = useState("");

//     const handleChange = (e, name) => {
//         setFormData(prev => ({ ...prev, [name]: e.target.value }));
//     };

//     // Láº¤Y TXHASH Tá»ª LOCALSTORAGE
//     const getStoredTxHash = (index) => {
//         return localStorage.getItem(`txHash_${index + 1}`) || null;
//     };

//     // Láº¤Y Táº¤T Cáº¢ GIAO Dá»ŠCH
//     const getAllTransactions = async () => {
//         try {
//             if (!ethereum) return;

//             const contract = getEthereumContract();
//             const rawTxs = await contract.getAllTransactions();

//             // Láº¥y event logs tá»« contract (giáº£ sá»­ contract phÃ¡t event Transfer hoáº·c tÃªn event phÃ¹ há»£p)
//             // events[i].transactionHash chá»©a txHash cá»§a giao dá»‹ch tÆ°Æ¡ng á»©ng
//             let events = [];
//             try {
//                 const filter = contract.filters.Transfer(); // if your event is named Transfer
//                 events = await contract.queryFilter(filter);
//             } catch (e) {
//                 console.warn("No events available or filter name mismatch:", e);
//             }

//             const structured = rawTxs.map((tx, idx) => {
//                 const storedHash = getStoredTxHash(idx);
//                 const isLatest = idx === rawTxs.length - 1;
//                 const hash = storedHash || (isLatest && lastTxHash) || 'Pending...';
                

//                 return {
//                     addressTo: tx.receiver,
//                     addressFrom: tx.sender,
//                     timestamp: new Date(tx.timestamp.toNumber() * 1000).toLocaleString(),
//                     message: tx.message,
//                     keyword: tx.keyword,
//                     amount: parseInt(tx.amount._hex) / 1e18,
//                     transactionHash: hash,
//                 };
//             });

//             setTransactions(structured);
//         } catch (error) {
//             console.error("getAllTransactions error:", error);
//         }
//     };

//     // KIá»‚M TRA VÃ ÄÃƒ Káº¾T Ná»I
//     const checkIfWalletIsConnected = async () => {
//         try {
//             if (!ethereum) return;

//             const accounts = await ethereum.request({ method: 'eth_accounts' });
//             if (accounts.length) {
//                 setCurrentAccount(accounts[0]);
//                 await getAllTransactions();
//             }
//         } catch (error) {
//             console.error(error);
//         }
//     };

//     // KIá»‚M TRA Sá» LÆ¯á»¢NG GIAO Dá»ŠCH
//     const checkIfTransactionsExist = async () => {
//         try {
//             if (!ethereum) return;

//             const contract = getEthereumContract();
//             const count = await contract.getTransactionCount();
//             const countNum = count.toNumber();

//             setTransactionCount(countNum);
//             localStorage.setItem("transactionCount", countNum.toString());
//         } catch (error) {
//             console.error(error);
//         }
//     };

//     // Káº¾T Ná»I VÃ
//     const connectWallet = async () => {
//         try {
//             if (!ethereum) return alert("Please install MetaMask");

//             const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
//             setCurrentAccount(accounts[0]);
//             await getAllTransactions();
//         } catch (error) {
//             console.error(error);
//             throw new Error("No ethereum object");
//         }
//     };

//     // Gá»¬I GIAO Dá»ŠCH
//     const sendTransaction = async () => {
//         try {
//             if (!ethereum) return alert("Please install MetaMask");

//             const { addressTo, amount, keyword, message } = formData;
//             if (!addressTo || !amount || !keyword || !message) {
//                 alert("Please fill all fields");
//                 return;
//             }

//             const contract = getEthereumContract();
//             const parsedAmount = ethers.utils.parseEther(amount);

//             // Gá»¬I ETH
//             await ethereum.request({
//                 method: 'eth_sendTransaction',
//                 params: [{
//                     from: currentAccount,
//                     to: addressTo,
//                     gas: "0x5208",
//                     value: parsedAmount._hex,
//                 }],
//             });

//             setIsLoading(true);
//             console.log("Submitting to blockchain...");

//             // Gá»ŒI CONTRACT
//             const tx = await contract.addToBlockchain(addressTo, parsedAmount, message, keyword);
//             setLastTxHash(tx.hash);

//             console.log(`Submitted: ${tx.hash}`);
//             await tx.wait();
//             console.log(`Confirmed: ${tx.hash}`);

//             // Láº¤Y INDEX Má»šI NHáº¤T
//             const count = await contract.getTransactionCount();
//             const countNum = count.toNumber();

//             // LÆ¯U HASH VÄ¨NH VIá»„N
//             localStorage.setItem(`txHash_${countNum}`, tx.hash);

//             // Cáº¬P NHáº¬T STATE
//             setTransactionCount(countNum);
//             localStorage.setItem("transactionCount", countNum.toString());

//             // Táº¢I Láº I GIAO Dá»ŠCH
//             await getAllTransactions();

//             setIsLoading(false);

//         } catch (error) {
//             setIsLoading(false);
//             console.error("sendTransaction error:", error);
//             alert("Transaction failed");
//         }
//     };
// // KIá»‚M TRA KHI COMPONENT ÄÆ¯á»¢C MOUNT
//     useEffect(() => {
//         checkIfWalletIsConnected();
//         checkIfTransactionsExist();

//         if (!ethereum) return;
//         // chuyen doi tai khoan tu doi khi tai khoan trong meta mask thay doi
//         ethereum.on("accountsChanged", async (accounts) => {
//             if (accounts.length > 0) {
//                 setCurrentAccount(accounts[0]);
//                 await getAllTransactions();
//             } else {
//                 setCurrentAccount("");
//             }
//         });
//     }, []);

//     return (
//         <TransactionContext.Provider value={{
//             connectWallet,
//             currentAccount,
//             formData,
//             setFormData,
//             handleChange,
//             sendTransaction,
//             transactions,
//             isLoading,
//             transactionCount
//         }}>
//             {children}
//         </TransactionContext.Provider>
//     );
// };

// import React, { useEffect, useState } from "react";
// import { ethers } from "ethers";
// import { contractABI, contractAddress } from "../utils/constants";

// export const TransactionContext = React.createContext();
// const { ethereum } = window;

// // ðŸ“Œ NHá»š ÄIá»€N BLOCK DEPLOY CONTRACT Táº I ÄÃ‚Y
// const DEPLOY_BLOCK = 45000000;

// // Táº¡o káº¿t ná»‘i contract
// const getEthereumContract = () => {
//   const provider = new ethers.providers.Web3Provider(ethereum);
//   const signer = provider.getSigner();
//   return new ethers.Contract(contractAddress, contractABI, signer);
// };

// // Chunk query theo giá»›i háº¡n RPC Songbird (30 blocks)
// const queryLogsChunked = async (contract, fromBlock, toBlock) => {
//   const logs = [];
//   const maxRange = 30;

//   for (let start = fromBlock; start <= toBlock; start += maxRange) {
//     const end = Math.min(start + maxRange, toBlock);
//     const filter = contract.filters.Transfer();

//     const chunkLogs = await contract.queryFilter(filter, start, end);
//     logs.push(...chunkLogs);
//   }
//   return logs;
// };

// export const TransactionProvider = ({ children }) => {
//   const [formData, setFormData] = useState({
//     addressTo: "",
//     amount: "",
//     keyword: "",
//     message: "",
//   });
//   const [currentAccount, setCurrentAccount] = useState("");
//   const [isLoading, setIsLoading] = useState(false);
//   const [transactionCount, setTransactionCount] = useState(0);
//   const [transactions, setTransactions] = useState([]);

//   const handleChange = (e, name) => {
//     setFormData(prev => ({ ...prev, [name]: e.target.value }));
//   };

//   // Láº¥y toÃ n bá»™ tx + txHash tá»« event logs
//   const getAllTransactions = async () => {
//     try {
//       if (!ethereum) return;

//       const provider = new ethers.providers.Web3Provider(ethereum);
//       const contract = getEthereumContract();

//       const rawTxs = await contract.getAllTransactions();
//       const latestBlock = await provider.getBlockNumber();

//       // ðŸ”¥ Láº¥y event Transfer theo chunk
//       const logs = await queryLogsChunked(contract, DEPLOY_BLOCK, latestBlock);

//       const structured = rawTxs.map((tx, idx) => {
//         const log = logs[idx];
//         const realTxHash = log?.transactionHash || "Pending...";

//         return {
//           addressTo: tx.receiver,
//           addressFrom: tx.sender,
//           timestamp: new Date(tx.timestamp.toNumber() * 1000).toLocaleString(),
//           message: tx.message,
//           keyword: tx.keyword,
//           amount: parseInt(tx.amount._hex) / 1e18,
//           transactionHash: realTxHash,
//         };
//       });

//       setTransactions(structured);
//     } catch (err) {
//       console.error("getAllTransactions error:", err);
//     }
//   };

//   // Check vÃ­
//   const checkIfWalletIsConnected = async () => {
//     try {
//       if (!ethereum) return;

//       const accounts = await ethereum.request({
//         method: "eth_accounts",
//       });

//       if (accounts.length) {
//         setCurrentAccount(accounts[0]);
//         await getAllTransactions();
//       }
//     } catch (err) {
//       console.error(err);
//     }
//   };

//   // Check sá»‘ lÆ°á»£ng transactions
//   const checkIfTransactionsExist = async () => {
//     try {
//       if (!ethereum) return;
//       const contract = getEthereumContract();
//       const count = await contract.getTransactionCount();
//       setTransactionCount(count.toNumber());
//     } catch (err) {
//       console.error(err);
//     }
//   };

//   // Káº¿t ná»‘i vÃ­
//   const connectWallet = async () => {
//     try {
//       if (!ethereum) return alert("Vui lÃ²ng cÃ i MetaMask");

//       const accounts = await ethereum.request({
//         method: "eth_requestAccounts",
//       });

//       setCurrentAccount(accounts[0]);
//       await getAllTransactions();
//     } catch (err) {
//       console.error(err);
//       throw new Error("No ethereum object");
//     }
//   };

//   // Gá»­i giao dá»‹ch
//   const sendTransaction = async () => {
//     try {
//       if (!ethereum) return alert("Vui lÃ²ng cÃ i MetaMask");

//       const { addressTo, amount, keyword, message } = formData;

//       if (!addressTo || !amount || !keyword || !message) {
//         alert("Vui lÃ²ng nháº­p Ä‘áº§y Ä‘á»§");
//         return;
//       }

//       const contract = getEthereumContract();
//       const parsedAmount = ethers.utils.parseEther(amount);

//       // Gá»­i ETH
//       await ethereum.request({
//         method: "eth_sendTransaction",
//         params: [
//           {
//             from: currentAccount,
//             to: addressTo,
//             gas: "0x5208",
//             value: parsedAmount._hex,
//           },
//         ],
//       });

//       setIsLoading(true);

//       // LÆ°u tx vÃ o contract
//       const tx = await contract.addToBlockchain(
//         addressTo,
//         parsedAmount,
//         message,
//         keyword
//       );

//       console.log("Submitted:", tx.hash);
//       await tx.wait();
//       console.log("Confirmed:", tx.hash);

//       // Update state
//       const count = await contract.getTransactionCount();
//       setTransactionCount(count.toNumber());

//       // Load láº¡i tx
//       await getAllTransactions();
//       setIsLoading(false);
//     } catch (err) {
//       setIsLoading(false);
//       console.error("Transaction error:", err);
//       alert("Giao dá»‹ch tháº¥t báº¡i!");
//     }
//   };

//   // Khi mount
//   useEffect(() => {
//     checkIfWalletIsConnected();
//     checkIfTransactionsExist();

//     if (!ethereum) return;

//     // Reload khi Ä‘á»•i vÃ­
//     ethereum.on("accountsChanged", async accounts => {
//       if (accounts.length > 0) {
//         setCurrentAccount(accounts[0]);
//         await getAllTransactions();
//       } else {
//         setCurrentAccount("");
//       }
//     });
//   }, []);

//   return (
//     <TransactionContext.Provider
//       value={{
//         connectWallet,
//         currentAccount,
//         formData,
//         setFormData,
//         handleChange,
//         sendTransaction,
//         transactions,
//         isLoading,
//         transactionCount,
//       }}
//     >
//       {children}
//     </TransactionContext.Provider>
//   );
// };