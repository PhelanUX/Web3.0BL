// import React, { Children, useEffect, useState} from "react";
// import {ethers } from 'ethers';

// import { contractABI, contractAddress} from  '../utils/constants';

// export const TransactionContext = React.createContext();

// const { ethereum } = window;

// const getEthereumContract = () => {
//     const provider = new ethers.providers.Web3Provider(ethereum);
//     const signer = provider.getSigner();
//     const transactionContract = new ethers.Contract(contractAddress, contractABI, signer);
    
//     return transactionContract;
// }

// export const TransactionProvider = ({children}) => {
//     const [formData, setformData] = useState({ addressTo: "", amount: "", keyword: "", message: "" });
//     const [currentAccount, setCurrentAccount] = useState("");
//     const [isLoading, setIsLoading] = useState(false);
//     const [transactionCount, setTransactionCount] = useState(localStorage.getItem('transactionCount'));
//     const [transactions,setTransactions] = useState([])
//     const [lastTxHash, setLastTxHash] = useState("");

//     const handleChange = (e, name) => {
//         setformData((prevState) => ({ ...prevState, [name]: e.target.value }))
//     }

//     const getAllTransactions = async () => {
//         try {
//             if(!ethereum) return alert("Please install metamask");
//             const transactionContract = getEthereumContract();
            
//             const availableTransactions = await transactionContract.getAllTransactions();

//             // const structuredTransactions = availableTransactions.map((transaction) => ({
//             //     //transactionHash: transaction.transactionHash,
//             //     addressTo: transaction.receiver,
//             //     addressFrom: transaction.sender,
//             //     timestamp: new Date(transaction.timestamp.toNumber()*1000).toLocaleString(),
//             //     message:transaction.message,
//             //     keyword:transaction.keyword,
//             //     amount: parseInt(transaction.amount._hex) / (10**18),                
//             // }))
//             const structuredTransactions = availableTransactions.map((transaction, index) => {
//                 const isLatest = index === availableTransactions.length - 1;
//                 return {
//                 //transactionHash: transaction.transactionHash,
//                 addressTo: transaction.receiver,
//                 addressFrom: transaction.sender,
//                 timestamp: new Date(transaction.timestamp.toNumber()*1000).toLocaleString(),
//                 message:transaction.message,
//                 keyword:transaction.keyword,
//                 amount: parseInt(transaction.amount._hex) / (10**18), 
//                 transactionHash: isLatest && lastTxHash ? lastTxHash : 'Pending...',               
//             }})

//             setTransactions(structuredTransactions);
//             console.log(structuredTransactions);
//         } catch (error) {
//             console.log(error);
//         }
//     }

//     const checkIfWalletIsConnected = async () => {
//         try {
//             if(!ethereum) return alert("Please install metamask");
    
//             const accounts = await ethereum.request({ method: 'eth_accounts' });
    
//             if(accounts.length){
//                 setCurrentAccount(accounts[0]);
    
//                 getAllTransactions();
//             } else {
//                 console.log("no account found");
//             }
    
//             console.log(accounts);  
//         } catch (error) {
//              console.log(error);
            
//         }
//     }

//     const checkIfTransactionsExist = async () =>{
//         try {
//             const transactionContract = getEthereumContract();
//             const transactionsCount = await transactionContract.getTransactionCount();
            
//             window.localStorage.setItem("transactionCount", transactionCount);
//         } catch (error) {
//             console.log(error);
//             throw new Error("No ethereum object")
//         }
//     }

//     //connect the wallet
//     const connectWallet = async () =>{
//         try {
//             if(!ethereum) return alert("Please install metamask");

//             const accounts = await ethereum.request({ method: 'eth_requestAccounts' });

//             setCurrentAccount(accounts[0]);
//             await getAllTransactions();
//             //window.location.reload();
//         } catch (error) {
//             console.log(error);
//             throw new Error("No ethereum object")
//         }
//     }

//     const sendTransaction = async () => {

//         try {
//             if(!ethereum) return alert("Please install metamask");

//             const { addressTo, amount, keyword, message } = formData;
//             const transactionContract = getEthereumContract();
//             const parsedAmount= ethers.utils.parseEther(amount);

//             await ethereum.request({
//                 method: 'eth_sendTransaction',
//                 params:[{
//                     from: currentAccount,
//                     to: addressTo,
//                     gas: '0x5208', //21000 GWEI
//                     value: parsedAmount._hex, //0.00001
//                 }]
//             });
//             setIsLoading(true);

//             //goi contract luu data k can hash
//             const tx = await transactionContract.addToBlockchain(addressTo, parsedAmount, message, keyword);
//             setLastTxHash(tx.hash);
//             await tx.wait();

//             //const transactionHash = await transactionContract.addToBlockchain(addressTo, parsedAmount, message, keyword);
//             //await transactionHash.wait();

//             console.log('Loading - ${transactionHash.hash}');
//             setIsLoading(false);
//             console.log('Success - ${transactionHash.hash}');

//             const transactionsCount = await transactionContract.getTransactionCount();

//             setTransactionCount(transactionsCount.toNumber());

//             await getAllTransactions();
//             //window.location.reload();
//         } catch (error) {
//             console.log(error);
//             throw new Error("No ethereum object")
//         }
//     } 

//     useEffect(() =>{
//         checkIfWalletIsConnected();
//         checkIfTransactionsExist();
//     }, []);

//     return(
//         <TransactionContext.Provider value={{ connectWallet, currentAccount, formData, setformData, handleChange, sendTransaction, transactions, isLoading }}>
//             {children}
//         </TransactionContext.Provider>
//     );
// } 